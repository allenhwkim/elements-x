<h1 id="dom-changed-event-using-mutationobserver"><code>dom-changed</code> Event Using MutationObserver</h1>
<p>To track the change of any element in your document, there was an event called DOMSubtreeModified, but this is not encouraged to use.</p>
<p>Luckily, we have a new way to do it, <code>[MutationObserver</code>](<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver</a>), which is compatible with on almost all modern browsers including IE11.</p>
<p>Here I provide very simple example to detect any change in your document.</p>
<pre><code>const observer = **new MutationObserver**(list =&gt; {
  console.log(‘mutation list’, list);
});
**observer.observe**(document.body, {attributes: true, childList: true, subtree: true});
// perform any DOM change action in your page. e.g. show/hide</code></pre>
<p>You copy/paste the above code into your console. Then you will see any DOM change events.</p>
<p><img src="https://cdn-images-1.medium.com/max/4224/1*TgNsev8jdQusqnjPJzVzVQ.png" alt=""></p>
<p>It works, yes it works, and it’s doable. However it seems something missing, and it’s not like any traditional event handling, e.g. click event handling.</p>
<p>Let’s change the above code to fire an event, <code>dom-changed, </code>so that any function can handle DOM event changes as an event.</p>
<p>It’s pretty simple. Instead of logging to console, fire a custom event from <code>document.body.</code></p>
<pre><code>const observer = **new MutationObserver**( list =&gt; {
  const evt = new CustomEvent(&#39;**dom-changed**&#39;, {detail: list});
  **document.body.dispatchEvent(evt)**
});
**observer.observe**(document.body, {attributes: true, childList: true, subtree: true});</code></pre>
<p>Now you can do to listen to any DOM change event in your body.</p>
<pre><code>document.body.addEventListener(&#39;**dom-changed**&#39;, e =&gt; console.log(e));</code></pre>
<p>Here is console message for the above code.</p>
<p><img src="https://cdn-images-1.medium.com/max/3624/1*uHwHQidCvFl35S1xOA4dZA.png" alt=""></p>
<p>This technique can be used to make a Promise response to wait for certain DOM contents instead of using <code>setTimeout</code>, or polling. As an example, let’s code a Promise function that waits for body text to have ‘Hello World’.</p>
<pre><code>function waitForText(el, text, maxWait=5000) {
  return new Promise(function(resolve, reject) {

    setTimeout(_ =&gt; { // when timeout, fail
      document.body.removeEventListener(&#39;dom-changed&#39;, checkFn);
      reject(&#39;Error finding text&#39;);
    }, maxWait);

    const checkFn = function() {
      if (el.innerText.includes(text)) {
        document.body.removeEventListener(&#39;dom-changed&#39;, checkFn);
        resolve(true);
      }
    };

    document.body.addEventListener(&#39;dom-changed&#39;, checkFn);
  })
}</code></pre>
<p>Hope it helps</p>
<p>Happy coding :)</p>
