<div class="medium-article"><style>
          figure { margin: 16px 0;}
          img {max-width: 100%; max-height: 100%;}
          .layout-1 { max-width: 680px; }
          .layout-3 { max-width: 1192px; }
          .layout-5 { width: 100%; }
          .layout-6 { width: 30%;}
          .layout-7 { width: 30%;}</style>
<h1 class="title">Angular: Monitor element is in viewport after scrolling</h1>
<h2>Render DOM only when visible</h2>
<div style="display:flex; flex-wrap: wrap"><figure class="layout-3"><img src="https://cdn-images-1.medium.com/max/700/0*jy3S4kbxU9-iPjkX" /><figcaption>Photo by <a href="https://unsplash.com/@plhrmnn?utm_source=medium&utm_medium=referral">Paul Hermann</a> on <a href="https://unsplash.com?utm_source=medium&utm_medium=referral">Unsplash</a></figcaption></figure></div>
<p>Let‚Äôs say you need to display a thousands of images.</p>
<pre>&lt;div class=‚Äùimg-container‚Äù *ngFor=‚Äùlet el of images; let i=index‚Äù><br/>  &lt;img src=‚Äùhttps://picsum.photos/600/300?image={{i}}"><br/>&lt;/div></pre>
<p>What‚Äôs the issue with the above code to display 1000 images?</p>
<p>The problem of the above code is it actually download 1000 images and make it ready to display. When you inspect the network activity, you can actually see it.</p>
<div style="display:flex; flex-wrap: wrap"><figure class="layout-1"><img src="https://cdn-images-1.medium.com/max/700/1*UAZ7MNOjq7KnHAs49ZLgPg.png" /><figcaption>Too many DOM elements are loading even though users don‚Äôt see those.</figcaption></figure></div>
<p>What you really want is to download images only when you are able to see those. The following is an Angular idea to do it. <span class="quote">*inView</span> only download image only if the image is in viewport.</p>
<div style="display:flex; flex-wrap: wrap"><figure class="layout-1"><img src="https://cdn-images-1.medium.com/max/700/1*_flLHMlTAzfoIwARCK0eJg.png" /><figcaption>The right amount of DOM elements, users can see, are loading.</figcaption></figure></div>
<pre>&lt;div class=‚Äùimg-container‚Äù *ngFor=‚Äùlet el of images; let i=index‚Äù><br/>  &lt;img <b>*inView</b> src=‚Äùhttps://picsum.photos/600/300?image={{i}}"><br/>&lt;/div></pre>
<p>The trick to do this is to use Angular structural directive, and make it to render only if the <span class="quote">img</span> tag is in viewport. How can you check if it‚Äôs in viewport? Luckily, we have <span class="quote">IntersectionObserver</span> , that allows to check the element is intersect with viewport or not.</p>
<p>Based on caniuse.com, IntersectionObserver is working on almost all browsers except Internet Explorer. To make it to work on IE, use this ployfill, <a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill">https://github.com/w3c/IntersectionObserver/tree/master/polyfill</a></p>
<div style="display:flex; flex-wrap: wrap"><figure class="layout-1"><img src="https://cdn-images-1.medium.com/max/700/1*L9qQrNX3UmHhBGg2cwA4cw.png" /><figcaption></figcaption></figure></div>
<p>The following is the summarized code of this directive, which has less than 50 lines of code.</p>
<div style="display:flex; flex-wrap: wrap"><figure class="layout-1"><iframe data-script="https://gist.github.com/allenhwkim/a9ae140d266909873b074de35e690263.js" style="display:none; max-width: 100%; border: 0" width="1280" title="*inView"></iframe>
                <script src="https://gist.github.com/allenhwkim/a9ae140d266909873b074de35e690263.js"></script><figcaption>in-view.ts</figcaption></figure></div>
<h2>Constructor</h2>
<pre>  constructor(<br/>    private vcRef: ViewContainerRef,<br/>    private tplRef: TemplateRef&lt;any><br/>  ) {}</pre>
<p>With <span class="quote">&lt;div *inView>A&lt;/div></span>, it can be converted to <span class="quote">&lt;ng-template [inView]>&lt;div>A&lt;/ng-template></span>.</p>
<p>With<span class="quote">&lt;ng-template [inView]>&lt;div>A&lt;/ng-template></span>, you may match to <span class="quote">[inView]</span> to ViewContainerRef and <span class="quote">ng-template</span> to TemplateRef.</p>
<h2><b>ngAfterViewInit</b></h2>
<pre>ngAfterViewInit() {<br/>    const commentEl = this.vcRef.element.nativeElement;<br/>    const elToObserve = commentEl.parentElement;<br/>    this.setMinWidthHeight(elToObserve);<br/>  <br/>    const observer = new IntersectionObserver(entries => {<br/>        entries.forEach(entry => {<br/>          this.renderContents(entry.isIntersecting)<br/>        });<br/>      }, {threshold: [0, .1, .9, 1]});<br/>    observer.observe(elToObserve);<br/>  }</pre>
<div class="list bulletin"><span class="quote">this.vcRef.element.nativeElement</span> :<span class="quote">&lt;ng-template></span> is expressed as a comment when it is rendered; <span class="quote">&lt;!--container--></span></div>
<div class="list bulletin">Because you cannot register IntersectionObserver to a comment, which is not an element, you need to observe its parent element.</div>
<div class="list bulletin">If the parent element does not have any width or height, you need to set minimum width and height to prevent all <span class="quote">*inView</span> elements rendered at the same time.</div>
<div class="list bulletin"><span class="quote">observer.observe(elToObserve)</span> will monitor if it is in viewport or not, and if it‚Äôs in viewport, it render HTML contents.</div>
<h2>renderContents</h2>
<pre>  renderContents(isInView) {<br/>    if (isInView && !this.alreadyRendered) {<br/>      this.vcRef.clear();<br/>      this.vcRef.createEmbeddedView(this.tplRef);<br/>      this.alreadyRendered = true;<br/>    }<br/>  }</pre>
<p>using <span class="quote">ViewContainerRef#createEmbeddedView</span> , it renders HTML contents ONLY if not rendered yet.</p>
<p>To see it working, follow stackblitz link</p>
<div style="display:flex; flex-wrap: wrap"><figure class="layout-1"><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fstackblitz.com%2Fedit%2Fangular-in-view%3Fembed%3D1%26file%3Dsrc%252Fapp%252Fapp.component.html%26view%3Dpreview&display_name=StackBlitz&url=https%3A%2F%2Fstackblitz.com%2Fedit%2Fangular-in-view%3Ffile%3Dsrc%252Fapp%252Fapp.component.html%26view%3Dpreview&image=https%3A%2F%2Fc.staticblitz.com%2Fassets%2Ficon-1d2450aadcf984376236c23cd2ab0ba231ddd1d85c9b72990ed2ede5b4974d1b.png&key=a19fcc184b9711e1b4764040d3dc5c07&type=text%2Fhtml&schema=stackblitz" width="745" height="400"></iframe><figcaption><a href="https://stackblitz.com/edit/angular-in-view?file=src%2Fapp%2Fapp.component.html">https://stackblitz.com/edit/angular-in-view?file=src%2Fapp%2Fapp.component.html</a></figcaption></figure></div>
<p>Happy Coding :)</p>
<p>This article is a part of <a href="https://medium.com/@allenhwkim/angular-random-how-tos-61be27cac0a2">Angular Random How-Tos</a>. You may find some useful articles for your daily development.</p>
<p><b>Do you think this useful? If so please;<br/>*</b> <b>Clap üëè button </b>belowÔ∏è to let others to see this too.<br/>* <a href="https://twitter.com/allenhwkim">Follow Allen on Twitter (@allenhwkim)</a></p>
<h1>References:</h1>
<div class="list bulletin"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API</a></div>
<div class="list bulletin"><a href="https://medium.com/allenhwkim/simple-lazy-loading-with-angular-716dd3b174a">https://medium.com/allenhwkim/simple-lazy-loading-with-angular-716dd3b174a</a></div>
<div class="list bulletin"><a href="https://medium.com/@allenhwkim/angular-create-my-own-ngif-bb4fc534cbe">https://medium.com/@allenhwkim/angular-create-my-own-ngif-bb4fc534cbe</a></div></div>