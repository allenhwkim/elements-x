<div class="medium-article"><style>
          figure { margin: 16px 0;}
          img {max-width: 100%; max-height: 100%;}
          .layout-1 { max-width: 680px; }
          .layout-3 { max-width: 1192px; }
          .layout-5 { width: 100%; }
          .layout-6 { width: 30%;}
          .layout-7 { width: 30%;}</style>
<h1 class="title">How To Parse Typescript From Source</h1>
<p>This is a short and summarized version of how to parse Typescript from source . You can read more about Typescript AST at <a href="https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API">the official documentation</a></p>
<p>I am writing this tutorial mainly to explain how <a href="https://github.com/allenhwkim/ngentest">ngentest</a> is written. However, this will be also useful who wants to know how to parse Typescript.</p>
<p>To start, let’s say you have a very simple Typescript file, <span class="quote">my.component.ts</span></p>
<pre>import { <b>Component</b> } from '<b>@angular/core</b>';</pre>
<pre>@<a href="https://angular.io/api/core/Component">Component</a>({<br/>  selector: 'my',<br/>  template: 'hello me.'<br/>})<br/>export class <b>MyComponent</b> {<br/>}</pre>
<p>The end goal for this tutorial is to get the following info from the above code using typescript parser, <span class="quote">typescript</span>.</p>
<div class="list bulletin">import info, <span class="quote">Component</span>, <span class="quote">@angular/core</span></div>
<div class="list bulletin">decorator name, <span class="quote">Component</span></div>
<div class="list bulletin">class name, <span class="quote">MyComponent</span></div>
<pre>const ts = <b>require('typescript')</b>;<br/>const node = <b>ts.createSourceFile</b>(<br/>  'x.ts',   // fileName<br/>  <b>fs.readFileSync('./my.component.ts', 'utf8')</b>, // sourceText<br/>  ts.ScriptTarget.Latest // langugeVersion<br/>);</pre>
<p>The source file, <span class="quote">my.component.ts</span>, is now parsed using <span class="quote">createSoureFile</span> function, and now you are ready to look into AST, Abstract Syntax Tree. When you print out node, you will see the following.</p>
<pre>console.log(node);<br/>> SourceFileObject {<br/>>   ...,<br/>>   <b>kind:</b> 273,<br/>>   <b>text: '...',<br/></b>>   ...<br/>> }<br/>ts.SyntaxKind[node.kind]<br/>> `SourceFile`</pre>
<p>Each node has property <span class="quote">kind</span>, a number, which represents the type of node. To read the string representation of node type, you can get it from <span class="quote">ts.SyntaxKind</span>.</p>
<h2>First, get import information.</h2>
<p>Every node has its children nodes and you can find them using the given function <span class="quote">forEachChild</span>.</p>
<pre>node.forEachChild(child => console.log(<b>ts.SyntaxKind[child.kind]</b>))<br/><b>> ImportDeclaration</b><br/>> ClassDeclaration<br/>> EndOfFileToken</pre>
<p>As you see above, ImportDeclaration is the node that has import statement info. To get the node, ImportDeclaration, you need to assign it to a variable.</p>
<pre>var importDecl;<br/>node.forEachChild(child => {<br/>  if (<b>ts.SyntaxKind[child.kind] === 'ImportDeclaration') </b>{<br/>    importDecl = child;<b><br/></b>  }<br/>});<br/>console.log(importDecl);<br/>> NodeObject {<br/>>   ...<br/>>  importClause:<br/>>   NodeObject {<br/>>    ...<br/>>    namedBindings:<br/>>      NodeObject {<br/>>        ...<br/>>        <b>elements: [Array]</b> } }, // this has info of `Component`<br/>>  moduleSpecifier:<br/>>   TokenObject {<br/>>     ...<br/>>     text: '<a href="http://twitter.com/angular/core">@angular/core</a>' },<br/>>  modifierFlagsCache: 536870912 }</pre>
<p>Now you have found the node that has import declaration info., <span class="quote">importDecl</span>, Now, let’s extract import file names, and module name from <span class="quote">importDecl</span>.</p>
<pre>importDecl.importClause.namedBindings.elements.map(<br/>  el => el.name.escapedText<br/>);<br/>> [ 'Component' ]<br/>importDecl.moduleSpecifier.text;<br/>> '@angular/core'</pre>
<h2>Second, get decorator name.</h2>
<p>From the given example file, decorator <span class="quote">@Component</span>belongs to class MyComponent.</p>
<pre><b>@Component</b>({<br/>  selector: 'my',<br/>  template: 'hello me.'<br/>})<br/>export class <b>MyComponent</b> {<br/>}</pre>
<p>Thus, you need to get class <span class="quote">MyComponent</span> from the parsed info. As the same way we get ImportDeclaration, we need to extract ClassDeclaration.</p>
<pre>var classDecl;<br/>node.forEachChild(child => {<br/>  if (<b>ts.SyntaxKind[child.kind] === 'ClassDeclaration') </b>{<br/>    classDecl = child;<b><br/></b>  }<br/>});<br/>console.log(classDecl);<br/>> NodeObject {<br/>>  ...<br/>>  decorators:<br/>>   [ NodeObject {<br/>>       ...<br/>>      <b> expression: [Object] </b>},  // @Component is here<br/>>     ...],<br/>>  name:<br/>>   IdentifierObject {<br/>>     ...<br/>>     escapedText: 'MyComponent' },<br/>>  ... }</pre>
<p>Now, let’s extract decorator name <span class="quote">Component</span>.</p>
<pre>classDecl.decorators[0].expression.expression.escapedText;<br/>> 'Component'</pre>
<h2>Last, get class name.</h2>
<pre>node.forEachChild(child => console.log(<b>ts.SyntaxKind[child.kind]</b>))<br/>> ImportDeclaration<br/><b>> ClassDeclaration</b><br/>> EndOfFileToken</pre>
<p>Getting class name is simpler than getting decorator info.</p>
<pre>node.forEachChild(child => {<br/>  if (<b>ts.SyntaxKind[child.kind] === 'ClassDeclaration') </b>{<br/>    classDecl = child;<b><br/></b>  }<br/>});<br/>console.log(classDecl);<br/>> NodeObject {<br/>>  ...,<br/>>  name:<br/>>   IdentifierObject {<br/>>     ...<br/>>     <b>escapedText: 'MyComponent' </b>}, // class name is here<br/>>  ... }</pre>
<p>Let’s get the class name.</p>
<pre>classDecl.name.escapedText<br/>> 'MyComponet'</pre>
<p>To summarize, the following is full code from this tutorial. You can simply copy/paste to experience it, e.g. <span class="quote">parse-typescript.js</span></p>
<pre>const ts = require('typescript');<br/><b>const node = ts.createSourceFile(</b><br/>  'x.ts',`<br/>    import { Component } from '<a href="http://twitter.com/angular/core">@angular/core</a>';<br/>    <a href="http://twitter.com/Component">@Component</a>({selector: 'my', template: 'hello me.' })<br/>    export class MyComponent {}`,<br/>  ts.ScriptTarget.Latest<br/>);</pre>
<pre><b>// Get import info.</b><br/>var importDecl;<br/>node.forEachChild(child => {<br/>  if (ts.SyntaxKind[child.kind] === 'ImportDeclaration') {<br/>    importDecl = child;<br/>  }<br/>});<br/>const importFiles = importDecl.importClause.namedBindings.elements.map(<br/>  el => el.name.escapedText<br/>);<br/>const importLib = importDecl.moduleSpecifier.text;</pre>
<pre><b>// Get decorator info.</b><br/>var classDecl;<br/>node.forEachChild(child => {<br/>  if (ts.SyntaxKind[child.kind] === 'ClassDeclaration') {<br/>    classDecl = child;<br/>  }<br/>});<br/>const decoratorName = classDecl.decorators[0].expression.expression.escapedText;<br/>const decoratorParams = <br/>  classDecl.decorators[0].expression.arguments.reduce((acc, el) => {<br/>    el.properties.forEach(<br/>      prop => acc[prop.name.escapedText] = prop.initializer.text<br/>    );<br/>    return acc;<br/>  }, {});</pre>
<pre><b>// Get class name</b><br/>const className =classDecl.name.escapedText</pre>
<pre>console.log({<br/>  importFiles,<br/>  importLib,<br/>  decoratorName,<br/>  decoratorParams,<br/>  className<br/>});</pre>
<p><span class="quote">$ node ./parse-typescript.js</span></p>
<pre>{ importFiles: [ 'Component' ],<br/>  importLib: '<a href="http://twitter.com/angular/core">@angular/core</a>',<br/>  decoratorName: 'Component',<br/>  decoratorParams: { selector: 'my', template: 'hello me.' },<br/>  className: 'MyComponent' }</pre>
<p>The above technique has been used to develop <a href="https://github.com/allenhwkim/ngentest">ngentest</a>, which creates Angular unit tests automatically, <a href="https://github.com/allenhwkim/ngentest">https://github.com/allenhwkim/ngentest</a>.</p>
<p><span class="quote">ngentest</span> is a Angular5,6,7,8+ unit test generator for components, directives, servides, and pipes, and it is heavily rely on typescript AST parsing. As you read its README.md it parses a Typescript file and get the following info.</p>
<div class="list bulletin">imports statements info.</div>
<div class="list bulletin">@Input statements info.</div>
<div class="list bulletin">@Output statements info.</div>
<div class="list bulletin">constructor providers info..</div>
<div class="list bulletin">selector info. used in @Component or @Directove decorator.</div>
<p>Hope this helps someone.</p>
<p>Happy coding :)</p></div>